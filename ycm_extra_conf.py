from distutils.sysconfig import get_python_inc
import platform
import os
import ycm_core

# These are the compilation flags that will be used in case there's no
# compilation database set (by default, one is not set).
# CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.
flags = [
# '-std=gnu++11',

# '-Wall',
# '-Wextra',
# '-Werror',

# #'-pedantic',

# '-Wconversion',
# '-Wunreachable-code',

# #'-pedantic-errors',

# # '-Wold-style-cast',
# # '-Weverything',
# '-Wshadow',
# '-Wfloat-equal',
# '-Weffc++',
# '-Wno-global-constructors',

# '-Wmost',

# '-Wno-weak-vtables',
# '-Wno-unused-member-function',

#'-Wno-long-long',
#'-Wno-variadic-macros',
#'-fexceptions',
# '-Wpedantic',

# '-DNDEBUG',

# You 100% do NOT need -DUSE_CLANG_COMPLETER and/or -DYCM_EXPORT in your flags;
# only the YCM source code needs it.
# '-DUSE_CLANG_COMPLETER',
# '-DYCM_EXPORT=',

# THIS IS IMPORTANT! Without the '-x' flag, Clang won't know which language to
# use when compiling headers. So it will guess. Badly. So C++ headers will be
# compiled as C headers. You don't want that so ALWAYS specify the '-x' flag.
# For a C project, you would set this to 'c' instead of 'c++'.
'-x', 'c++',
# 'cuda', '--cuda-path=/usr/local/cuda-9.2'

  #'-D__device__=',

# '-isystem',
# '../BoostParts',
# '-isystem',
# get_python_inc(),
# '-isystem',
# '../llvm/include',
# '-isystem',
# '../llvm/tools/clang/include',

#'-I',
#'.',

# '-I',
# './ClangCompleter',
# '-isystem',
# './tests/gmock/gtest',
# '-isystem',
# './tests/gmock/gtest/include',
# '-isystem',
# './tests/gmock',
# '-isystem',
# './tests/gmock/include',
# '-isystem',
# './benchmarks/benchmark/include',
]

# Clang automatically sets the '-std=' flag to 'c++14' for MSVC 2015 or later,
# which is required for compiling the standard library, and to 'c++11' for older
# versions.
# if platform.system() != 'Windows':
  # flags.append( '-std=c++11' )


# Set this to the absolute path to the folder (NOT the file!) containing the
# compile_commands.json file to use that instead of 'flags'. See here for
# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
#
# You can get CMake to generate this file for you by adding:
#   set( CMAKE_EXPORT_COMPILE_COMMANDS 1 )
# to your CMakeLists.txt file.
#
# Most projects will NOT need to set this to anything; you can just change the
# 'flags' list of compilation flags. Notice that YCM itself uses that approach.
compilation_database_folder = os.getcwd()

#if os.path.exists( compilation_database_folder ):
# if os.path.exists(os.path.join(compilation_database_folder,
                               # 'compile_commands.json')):
  # database = ycm_core.CompilationDatabase( compilation_database_folder )
# else:
  # database = None
database = None
if os.path.exists(os.path.join(compilation_database_folder,
                               'compile_commands.json')):
  database = ycm_core.CompilationDatabase( compilation_database_folder )

SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm', '.cu']

def DirectoryOfThisScript():
  return os.getcwd()
  # return os.path.dirname( os.path.abspath( __file__ ) )


def IsHeaderFile( filename ):
  extension = os.path.splitext( filename )[ 1 ]
  return extension in [ '.h', '.hxx', '.hpp', '.hh', '.cuh' ]


def GetCompilationInfoForFile(filename):
  # The compilation_commands.json file generated by CMake does not have entries
  # for header files. So we do our best by asking the db for flags for a
  # corresponding source file, if any. If one exists, the flags for that file
  # should be good enough.
  if IsHeaderFile( filename ):
    basename = os.path.splitext( filename )[ 0 ]
    for extension in SOURCE_EXTENSIONS:
      replacement_file = basename + extension
      if os.path.exists( replacement_file ):
        compilation_info = database.GetCompilationInfoForFile(
          replacement_file )
        if compilation_info.compiler_flags_:
          return compilation_info
    return None
  return database.GetCompilationInfoForFile( filename )

def prepare_includes(*paths):
  as_flags = []
  for path in paths:
    as_flags.append('-I')
    as_flags.append(path)
  return as_flags

CONDADIR = os.environ.get('CONDA_PREFIX', '/')

BASE_FLAGS = prepare_includes(
  # '/usr/include/c++/5',
  # '/usr/include/c++/5/bits',
  # '/usr/include/x86_64-linux-gnu/c++/5',
  # '/usr/include/c++/5/tr1',
  # '/usr/include/c++/5/tr2',
  '/usr/local/cuda-9.2/include',
  # '/home/gcca/src/llvm/projects/libcxx/include',


  # '/home/gcca/opt/miniconda2/envs/ucx/ucx/prefix/include',
  # '/home/gcca/opt/miniconda2/envs/ucx/ucx/src',
  # '/home/gcca/opt/miniconda2/envs/ucx/ucx/test/gtest',

  # '/home/gcca/src/googletest/build/prefix/include',
  # '/home/gcca/src/flatbuffers/build/prefix/include',

  # ----- BLAZING
  os.path.join(CONDADIR, 'include'),
  os.path.join(CONDADIR, 'blazingsql/engine/src'),
)

BASE_FLAGS += [
  '-std=gnu++14',
  '-Wall',
  '-Werror',
  '-Wextra',
  # '-pedantic'
  # '-Wpedantic',
  '-pedantic-errors',

  # '-Wconversion',
  # '-Wunreachable-code',
  # '-Wuninitialized',
  # '-Wold-style-cast',
  # '-Wshadow-all',
  '-Wmost',

  # '-Weverything',
  '-Wno-c++98-compat',
  '-Wno-c++98-compat-pedantic',

  '-rdynamic',

  #'-Wno-old-style-cast'
]

def FlagsForFile(filename, **kwargs):
  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
  # # if filename.endswith('.cu') or filename.endswith('.cuh'):
    # # flags.extend(['-x', 'c++'])
    # # #flags.extend(['-x', 'cuda', '--cuda-gpu-arch=sm_35'])
  # # else:
    # # flags.extend(['-x', 'c++'])
  # return {
    # 'flags': flags + BASE_FLAGS,
    # # 'do_cache': True,
    # # 'flags_ready': True,
    # #'include_paths_relative_to_dir': DirectoryOfThisScript()
  # }
  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

  global database
  database = None
  dirbase = filename
  while '/' != dirbase:
    dirbase = os.path.dirname(dirbase)
    if os.path.exists(os.path.join(dirbase, 'compile_commands.json')):
        database = ycm_core.CompilationDatabase(dirbase)
        break
    if os.path.exists(os.path.join(os.path.join(dirbase, 'build'),
                                   'compile_commands.json')):
        database = ycm_core.CompilationDatabase(dirbase)
        break

  if not database:
    return {
      'flags': BASE_FLAGS + flags,
      'include_paths_relative_to_dir': DirectoryOfThisScript()
    }

  compilation_info = GetCompilationInfoForFile( filename )
  # with open('/dev/shm/sal.txt', 'w') as f:
    # f.write(compilation_info)

  if not compilation_info:
    return {
      'flags': BASE_FLAGS,
      'include_paths_relative_to_dir': DirectoryOfThisScript()
    }

  # Bear in mind that compilation_info.compiler_flags_ does NOT return a
  # python list, but a "list-like" StringVec object.
  final_flags = list( compilation_info.compiler_flags_ ) + BASE_FLAGS

  # NOTE: This is just for YouCompleteMe; it's highly likely that your project
  # does NOT need to remove the stdlib flag. DO NOT USE THIS IN YOUR
  # ycm_extra_conf IF YOU'RE NOT 100% SURE YOU NEED IT.
  # try:
    # final_flags.remove( '-stdlib=libc++' )
  # except ValueError:
    # pass

  return {
    'flags': final_flags,
    'include_paths_relative_to_dir': compilation_info.compiler_working_dir_
  }
